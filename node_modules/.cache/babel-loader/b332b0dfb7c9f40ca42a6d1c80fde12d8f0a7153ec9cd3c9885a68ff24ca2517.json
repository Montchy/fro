{"ast":null,"code":"import ApiService from \"../Application/ApiService\";\n\n/**\n * Ruft alle Personen aus verschiedenen Endpunkten ab und führt sie zu einer Liste zusammen.\n * @returns {Promise<Array>} - Eine zusammengeführte Liste von Personen.\n */\nexport const fetchAllPersons = async () => {\n  try {\n    // Daten aus verschiedenen Endpunkten abrufen\n    const vermittler = await fetchAndLog(\"Vermittler\", ApiService.fetchVermittler);\n    const einbringer = await fetchAndLog(\"Einbringer\", ApiService.fetchEinbringer);\n    const betreuer = await fetchAndLog(\"Betreuer\", ApiService.fetchBetreuer);\n\n    // Zusammenführen und Bereinigen der Daten\n    const allPersons = [...sanitizePersons(vermittler, \"Vermittler\"), ...sanitizePersons(einbringer, \"Einbringer\"), ...sanitizePersons(betreuer, \"Betreuer\")];\n    console.log(\"Zusammengeführte Personenliste:\", allPersons);\n    return allPersons;\n  } catch (error) {\n    console.error(\"Fehler beim Abrufen der Personen:\", error);\n    throw error; // Fehler weiterwerfen, um das Problem zu propagieren\n  }\n};\n\n/**\n * Führt eine Fetch-Funktion aus, protokolliert die Antwort und behandelt Fehler.\n * @param {string} type - Der Typ der Datenquelle (z. B. \"Vermittler\").\n * @param {Function} fetchFunction - Die Fetch-Funktion für die API.\n * @returns {Promise<Array>} - Die API-Antwort als Array oder ein leeres Array bei Fehlern.\n */\nconst fetchAndLog = async (type, fetchFunction) => {\n  try {\n    const response = await fetchFunction();\n    if (response instanceof ReadableStream) {\n      console.warn(`${type} API hat einen Stream zurückgegeben. Wird in JSON konvertiert...`);\n      const json = await new Response(response).json();\n      console.log(`${type} Response (konvertiert):`, json);\n      return Array.isArray(json) ? json : [];\n    }\n    if (!Array.isArray(response)) {\n      console.warn(`${type} API hat kein Array zurückgegeben:`, response);\n      return []; // Leeres Array zurückgeben, falls die Antwort kein Array ist\n    }\n    console.log(`${type} Response:`, response);\n    return response;\n  } catch (error) {\n    console.error(`Fehler beim Abrufen von ${type}:`, error);\n    return []; // Fehler protokollieren und ein leeres Array zurückgeben\n  }\n};\n\n/**\n * Bereinigt und formatiert die Liste der Personen aus einer bestimmten Quelle.\n * @param {Array} persons - Die ursprüngliche Personenliste.\n * @param {string} type - Der Typ der Quelle (z. B. \"Vermittler\", \"Einbringer\", \"Betreuer\").\n * @returns {Array} - Die bereinigte und formattierte Personenliste.\n */\nconst sanitizePersons = (persons, type) => {\n  if (!Array.isArray(persons)) {\n    console.warn(`Erwartete ein Array, aber erhalten:`, persons);\n    return []; // Leeres Array zurückgeben, falls das Argument kein Array ist\n  }\n  return persons.map(person => {\n    var _person$email, _person$adresse, _person$adresse2, _person$adresse3;\n    return {\n      id: person.id,\n      vorname: person.vorname || \"Unbekannt\",\n      nachname: person.nachname || \"Unbekannt\",\n      email: ((_person$email = person.email) === null || _person$email === void 0 ? void 0 : _person$email.address) || \"Keine Email\",\n      telefon: person.tel || \"Keine Telefonnummer\",\n      adresse: [((_person$adresse = person.adresse) === null || _person$adresse === void 0 ? void 0 : _person$adresse.strasse) || \"\", ((_person$adresse2 = person.adresse) === null || _person$adresse2 === void 0 ? void 0 : _person$adresse2.ort) || \"\", ((_person$adresse3 = person.adresse) === null || _person$adresse3 === void 0 ? void 0 : _person$adresse3.land) || \"\"].filter(Boolean).join(\", \"),\n      // Nur vorhandene Adressbestandteile einfügen\n      typ: type // Typ der Quelle hinzufügen\n    };\n  });\n};","map":{"version":3,"names":["ApiService","fetchAllPersons","vermittler","fetchAndLog","fetchVermittler","einbringer","fetchEinbringer","betreuer","fetchBetreuer","allPersons","sanitizePersons","console","log","error","type","fetchFunction","response","ReadableStream","warn","json","Response","Array","isArray","persons","map","person","_person$email","_person$adresse","_person$adresse2","_person$adresse3","id","vorname","nachname","email","address","telefon","tel","adresse","strasse","ort","land","filter","Boolean","join","typ"],"sources":["/Users/amelieploil/Desktop/Diploma/kinskyfe/src/Application/personService.js"],"sourcesContent":["import ApiService from \"../Application/ApiService\";\n\n/**\n * Ruft alle Personen aus verschiedenen Endpunkten ab und führt sie zu einer Liste zusammen.\n * @returns {Promise<Array>} - Eine zusammengeführte Liste von Personen.\n */\nexport const fetchAllPersons = async () => {\n    try {\n        // Daten aus verschiedenen Endpunkten abrufen\n        const vermittler = await fetchAndLog(\"Vermittler\", ApiService.fetchVermittler);\n        const einbringer = await fetchAndLog(\"Einbringer\", ApiService.fetchEinbringer);\n        const betreuer = await fetchAndLog(\"Betreuer\", ApiService.fetchBetreuer);\n\n        // Zusammenführen und Bereinigen der Daten\n        const allPersons = [\n            ...sanitizePersons(vermittler, \"Vermittler\"),\n            ...sanitizePersons(einbringer, \"Einbringer\"),\n            ...sanitizePersons(betreuer, \"Betreuer\"),\n        ];\n\n        console.log(\"Zusammengeführte Personenliste:\", allPersons);\n        return allPersons;\n    } catch (error) {\n        console.error(\"Fehler beim Abrufen der Personen:\", error);\n        throw error; // Fehler weiterwerfen, um das Problem zu propagieren\n    }\n};\n\n/**\n * Führt eine Fetch-Funktion aus, protokolliert die Antwort und behandelt Fehler.\n * @param {string} type - Der Typ der Datenquelle (z. B. \"Vermittler\").\n * @param {Function} fetchFunction - Die Fetch-Funktion für die API.\n * @returns {Promise<Array>} - Die API-Antwort als Array oder ein leeres Array bei Fehlern.\n */\nconst fetchAndLog = async (type, fetchFunction) => {\n    try {\n        const response = await fetchFunction();\n\n        if (response instanceof ReadableStream) {\n            console.warn(`${type} API hat einen Stream zurückgegeben. Wird in JSON konvertiert...`);\n            const json = await new Response(response).json();\n            console.log(`${type} Response (konvertiert):`, json);\n            return Array.isArray(json) ? json : [];\n        }\n\n        if (!Array.isArray(response)) {\n            console.warn(`${type} API hat kein Array zurückgegeben:`, response);\n            return []; // Leeres Array zurückgeben, falls die Antwort kein Array ist\n        }\n\n        console.log(`${type} Response:`, response);\n        return response;\n    } catch (error) {\n        console.error(`Fehler beim Abrufen von ${type}:`, error);\n        return []; // Fehler protokollieren und ein leeres Array zurückgeben\n    }\n};\n\n/**\n * Bereinigt und formatiert die Liste der Personen aus einer bestimmten Quelle.\n * @param {Array} persons - Die ursprüngliche Personenliste.\n * @param {string} type - Der Typ der Quelle (z. B. \"Vermittler\", \"Einbringer\", \"Betreuer\").\n * @returns {Array} - Die bereinigte und formattierte Personenliste.\n */\nconst sanitizePersons = (persons, type) => {\n    if (!Array.isArray(persons)) {\n        console.warn(`Erwartete ein Array, aber erhalten:`, persons);\n        return []; // Leeres Array zurückgeben, falls das Argument kein Array ist\n    }\n\n    return persons.map(person => ({\n        id: person.id,\n        vorname: person.vorname || \"Unbekannt\",\n        nachname: person.nachname || \"Unbekannt\",\n        email: person.email?.address || \"Keine Email\",\n        telefon: person.tel || \"Keine Telefonnummer\",\n        adresse: [\n            person.adresse?.strasse || \"\",\n            person.adresse?.ort || \"\",\n            person.adresse?.land || \"\",\n        ].filter(Boolean).join(\", \"), // Nur vorhandene Adressbestandteile einfügen\n        typ: type, // Typ der Quelle hinzufügen\n    }));\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}