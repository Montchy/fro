{"ast":null,"code":"import ApiService from \"../Application/ApiService\";\n\n/**\n * Führt eine Fetch-Funktion aus, protokolliert die Antwort und behandelt Fehler.\n * @param {string} type - Der Typ der Datenquelle (z. B. \"Auktion\", \"Exponat\").\n * @param {Function} fetchFunction - Die Fetch-Funktion für die API.\n * @returns {Promise<Array>} - Die bereinigte API-Antwort oder ein leeres Array.\n */\nconst fetchAndLog = async (type, fetchFunction) => {\n  try {\n    const response = await fetchFunction();\n    if (!response) {\n      console.warn(`${type} API hat keine Daten zurückgegeben.`);\n      return [];\n    }\n\n    //console.log(`Raw ${type} response:`, response);\n\n    const sanitizedResponse = sanitizeData(response);\n    //console.log(`Sanitized ${type} data:`, sanitizedResponse);\n\n    return sanitizedResponse;\n  } catch (error) {\n    console.error(`Fehler beim Abrufen von ${type}:`, error);\n    return [];\n  }\n};\n\n/**\n * Entfernt zirkuläre Referenzen und verschachtelte Strukturen.\n * @param {Object} data - Die zu bereinigenden Daten.\n * @param {Set} seen - Set, um bereits besuchte Objekte zu verfolgen.\n * @returns {Object} - Bereinigte Daten.\n */\nconst sanitizeData = (data, seen = new WeakSet()) => {\n  if (data && typeof data === \"object\") {\n    if (seen.has(data)) {\n      return undefined; // Zirkuläre Referenzen entfernen\n    }\n    seen.add(data);\n    const sanitized = Array.isArray(data) ? [] : {};\n    for (const key in data) {\n      sanitized[key] = sanitizeData(data[key], seen);\n    }\n    return sanitized;\n  }\n  return data;\n};\n\n/**\n * Ruft alle relevanten Daten für die Diagramme aus verschiedenen Endpunkten ab.\n * @returns {Promise<Object>} - Ein Objekt mit allen aggregierten Daten.\n */\nexport const fetchChartData = async () => {\n  try {\n    const vermittler = await fetchAndLog(\"Vermittler\", ApiService.fetchVermittler);\n    const einbringer = await fetchAndLog(\"Einbringer\", ApiService.fetchEinbringer);\n    const betreuer = await fetchAndLog(\"Betreuer\", ApiService.fetchBetreuer);\n    const exponate = await fetchAndLog(\"Exponate\", ApiService.fetchExponate);\n    const auktionen = await fetchAndLog(\"Auktionen\", ApiService.fetchAuktionen);\n    return {\n      vermittler: aggregateData(vermittler, \"typ\"),\n      einbringer: aggregateData(einbringer, \"typ\"),\n      betreuer: aggregateData(betreuer, \"typ\"),\n      exponate: aggregateData(exponate, \"kategorie\"),\n      auktionen: aggregateData(auktionen, \"datum\")\n    };\n  } catch (error) {\n    console.error(\"Fehler beim Abrufen der Diagrammdaten:\", error);\n    throw error;\n  }\n};\n\n/**\n * Aggregiert die Daten nach einem bestimmten Schlüssel.\n * @param {Array} data - Die Daten, die aggregiert werden sollen.\n * @param {string} key - Der Schlüssel, nach dem gruppiert werden soll.\n * @returns {Array} - Die aggregierten Daten.\n */\nconst aggregateData = (data, key) => {\n  if (!Array.isArray(data)) return [];\n  const aggregated = data.reduce((acc, item) => {\n    const groupKey = item[key] || \"Unbekannt\";\n    acc[groupKey] = acc[groupKey] || {\n      label: groupKey,\n      value: 0\n    };\n    acc[groupKey].value += 1; // Hier wird gezählt, Sie können es anpassen\n    return acc;\n  }, {});\n  return Object.values(aggregated);\n};\nexport default fetchChartData;","map":{"version":3,"names":["ApiService","fetchAndLog","type","fetchFunction","response","console","warn","sanitizedResponse","sanitizeData","error","data","seen","WeakSet","has","undefined","add","sanitized","Array","isArray","key","fetchChartData","vermittler","fetchVermittler","einbringer","fetchEinbringer","betreuer","fetchBetreuer","exponate","fetchExponate","auktionen","fetchAuktionen","aggregateData","aggregated","reduce","acc","item","groupKey","label","value","Object","values"],"sources":["/Users/amelieploil/Desktop/Diploma/kinskyfe/src/Application/chartService.js"],"sourcesContent":["import ApiService from \"../Application/ApiService\";\n\n/**\n * Führt eine Fetch-Funktion aus, protokolliert die Antwort und behandelt Fehler.\n * @param {string} type - Der Typ der Datenquelle (z. B. \"Auktion\", \"Exponat\").\n * @param {Function} fetchFunction - Die Fetch-Funktion für die API.\n * @returns {Promise<Array>} - Die bereinigte API-Antwort oder ein leeres Array.\n */\nconst fetchAndLog = async (type, fetchFunction) => {\n    try {\n        const response = await fetchFunction();\n\n        if (!response) {\n            console.warn(`${type} API hat keine Daten zurückgegeben.`);\n            return [];\n        }\n\n        //console.log(`Raw ${type} response:`, response);\n\n        const sanitizedResponse = sanitizeData(response);\n        //console.log(`Sanitized ${type} data:`, sanitizedResponse);\n\n        return sanitizedResponse;\n    } catch (error) {\n        console.error(`Fehler beim Abrufen von ${type}:`, error);\n        return [];\n    }\n};\n\n/**\n * Entfernt zirkuläre Referenzen und verschachtelte Strukturen.\n * @param {Object} data - Die zu bereinigenden Daten.\n * @param {Set} seen - Set, um bereits besuchte Objekte zu verfolgen.\n * @returns {Object} - Bereinigte Daten.\n */\nconst sanitizeData = (data, seen = new WeakSet()) => {\n    if (data && typeof data === \"object\") {\n        if (seen.has(data)) {\n            return undefined; // Zirkuläre Referenzen entfernen\n        }\n        seen.add(data);\n\n        const sanitized = Array.isArray(data) ? [] : {};\n        for (const key in data) {\n            sanitized[key] = sanitizeData(data[key], seen);\n        }\n        return sanitized;\n    }\n    return data;\n};\n\n/**\n * Ruft alle relevanten Daten für die Diagramme aus verschiedenen Endpunkten ab.\n * @returns {Promise<Object>} - Ein Objekt mit allen aggregierten Daten.\n */\nexport const fetchChartData = async () => {\n    try {\n        const vermittler = await fetchAndLog(\"Vermittler\", ApiService.fetchVermittler);\n        const einbringer = await fetchAndLog(\"Einbringer\", ApiService.fetchEinbringer);\n        const betreuer = await fetchAndLog(\"Betreuer\", ApiService.fetchBetreuer);\n        const exponate = await fetchAndLog(\"Exponate\", ApiService.fetchExponate);\n        const auktionen = await fetchAndLog(\"Auktionen\", ApiService.fetchAuktionen);\n\n        return {\n            vermittler: aggregateData(vermittler, \"typ\"),\n            einbringer: aggregateData(einbringer, \"typ\"),\n            betreuer: aggregateData(betreuer, \"typ\"),\n            exponate: aggregateData(exponate, \"kategorie\"),\n            auktionen: aggregateData(auktionen, \"datum\"),\n        };\n    } catch (error) {\n        console.error(\"Fehler beim Abrufen der Diagrammdaten:\", error);\n        throw error;\n    }\n};\n\n/**\n * Aggregiert die Daten nach einem bestimmten Schlüssel.\n * @param {Array} data - Die Daten, die aggregiert werden sollen.\n * @param {string} key - Der Schlüssel, nach dem gruppiert werden soll.\n * @returns {Array} - Die aggregierten Daten.\n */\nconst aggregateData = (data, key) => {\n    if (!Array.isArray(data)) return [];\n\n    const aggregated = data.reduce((acc, item) => {\n        const groupKey = item[key] || \"Unbekannt\";\n        acc[groupKey] = acc[groupKey] || { label: groupKey, value: 0 };\n        acc[groupKey].value += 1; // Hier wird gezählt, Sie können es anpassen\n        return acc;\n    }, {});\n\n    return Object.values(aggregated);\n};\n\nexport default fetchChartData;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}