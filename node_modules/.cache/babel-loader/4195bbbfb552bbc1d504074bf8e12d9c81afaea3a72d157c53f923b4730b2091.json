{"ast":null,"code":"import ApiService from \"../Application/ApiService\";\n\n/**\n * Hilfsfunktion, um Personen aus verschiedenen Endpunkten abzurufen und zu einer Liste zusammenzuführen.\n * @returns {Promise<Array>} - Eine Liste von Personen.\n */\nexport const fetchAllPersons = async () => {\n  try {\n    // Daten aus verschiedenen Endpunkten abrufen\n    const vermittler = await ApiService.fetchVermittler(); // Vermutlich `/api/vermittler`\n    const einbringer = await ApiService.fetchEinbringer(); // Vermutlich `/api/einbringer`\n    const betreuer = await ApiService.fetchBetreuer(); // Vermutlich `/api/betreuer`\n\n    // Alle Personen zusammenführen\n    const allPersons = [...sanitizePersons(vermittler, \"Vermittler\"), ...sanitizePersons(einbringer, \"Einbringer\"), ...sanitizePersons(betreuer, \"Betreuer\")];\n    return allPersons;\n  } catch (error) {\n    console.error(\"Fehler beim Abrufen der Personen:\", error);\n    throw error;\n  }\n};\n\n/**\n * Bereinigt und markiert Personen aus einer bestimmten Quelle.\n * @param {Array} persons - Die ursprüngliche Personenliste.\n * @param {string} type - Der Typ der Quelle (z. B. \"Vermittler\", \"Einbringer\", \"Betreuer\").\n * @returns {Array} - Die bereinigte Personenliste.\n */\nconst sanitizePersons = (persons, type) => {\n  if (!Array.isArray(persons)) return [];\n  return persons.map(person => {\n    var _person$email, _person$adresse, _person$adresse2, _person$adresse3;\n    return {\n      id: person.id,\n      vorname: person.vorname,\n      nachname: person.nachname,\n      email: ((_person$email = person.email) === null || _person$email === void 0 ? void 0 : _person$email.address) || \"Keine Email\",\n      telefon: person.tel || \"Keine Telefonnummer\",\n      adresse: `${((_person$adresse = person.adresse) === null || _person$adresse === void 0 ? void 0 : _person$adresse.strasse) || \"\"}, ${((_person$adresse2 = person.adresse) === null || _person$adresse2 === void 0 ? void 0 : _person$adresse2.ort) || \"\"}, ${((_person$adresse3 = person.adresse) === null || _person$adresse3 === void 0 ? void 0 : _person$adresse3.land) || \"\"}`,\n      typ: type // Hinzufügen des Typs (z. B. \"Vermittler\", \"Einbringer\", \"Betreuer\")\n    };\n  });\n};","map":{"version":3,"names":["ApiService","fetchAllPersons","vermittler","fetchVermittler","einbringer","fetchEinbringer","betreuer","fetchBetreuer","allPersons","sanitizePersons","error","console","persons","type","Array","isArray","map","person","_person$email","_person$adresse","_person$adresse2","_person$adresse3","id","vorname","nachname","email","address","telefon","tel","adresse","strasse","ort","land","typ"],"sources":["/Users/amelieploil/Desktop/Diploma/kinskyfe/src/Application/personService.js"],"sourcesContent":["import ApiService from \"../Application/ApiService\";\n\n/**\n * Hilfsfunktion, um Personen aus verschiedenen Endpunkten abzurufen und zu einer Liste zusammenzuführen.\n * @returns {Promise<Array>} - Eine Liste von Personen.\n */\nexport const fetchAllPersons = async () => {\n    try {\n        // Daten aus verschiedenen Endpunkten abrufen\n        const vermittler = await ApiService.fetchVermittler(); // Vermutlich `/api/vermittler`\n        const einbringer = await ApiService.fetchEinbringer(); // Vermutlich `/api/einbringer`\n        const betreuer = await ApiService.fetchBetreuer(); // Vermutlich `/api/betreuer`\n\n        // Alle Personen zusammenführen\n        const allPersons = [\n            ...sanitizePersons(vermittler, \"Vermittler\"),\n            ...sanitizePersons(einbringer, \"Einbringer\"),\n            ...sanitizePersons(betreuer, \"Betreuer\"),\n        ];\n\n        return allPersons;\n    } catch (error) {\n        console.error(\"Fehler beim Abrufen der Personen:\", error);\n        throw error;\n    }\n};\n\n/**\n * Bereinigt und markiert Personen aus einer bestimmten Quelle.\n * @param {Array} persons - Die ursprüngliche Personenliste.\n * @param {string} type - Der Typ der Quelle (z. B. \"Vermittler\", \"Einbringer\", \"Betreuer\").\n * @returns {Array} - Die bereinigte Personenliste.\n */\nconst sanitizePersons = (persons, type) => {\n    if (!Array.isArray(persons)) return [];\n\n    return persons.map(person => ({\n        id: person.id,\n        vorname: person.vorname,\n        nachname: person.nachname,\n        email: person.email?.address || \"Keine Email\",\n        telefon: person.tel || \"Keine Telefonnummer\",\n        adresse: `${person.adresse?.strasse || \"\"}, ${person.adresse?.ort || \"\"}, ${person.adresse?.land || \"\"}`,\n        typ: type, // Hinzufügen des Typs (z. B. \"Vermittler\", \"Einbringer\", \"Betreuer\")\n    }));\n};"],"mappings":"AAAA,OAAOA,UAAU,MAAM,2BAA2B;;AAElD;AACA;AACA;AACA;AACA,OAAO,MAAMC,eAAe,GAAG,MAAAA,CAAA,KAAY;EACvC,IAAI;IACA;IACA,MAAMC,UAAU,GAAG,MAAMF,UAAU,CAACG,eAAe,CAAC,CAAC,CAAC,CAAC;IACvD,MAAMC,UAAU,GAAG,MAAMJ,UAAU,CAACK,eAAe,CAAC,CAAC,CAAC,CAAC;IACvD,MAAMC,QAAQ,GAAG,MAAMN,UAAU,CAACO,aAAa,CAAC,CAAC,CAAC,CAAC;;IAEnD;IACA,MAAMC,UAAU,GAAG,CACf,GAAGC,eAAe,CAACP,UAAU,EAAE,YAAY,CAAC,EAC5C,GAAGO,eAAe,CAACL,UAAU,EAAE,YAAY,CAAC,EAC5C,GAAGK,eAAe,CAACH,QAAQ,EAAE,UAAU,CAAC,CAC3C;IAED,OAAOE,UAAU;EACrB,CAAC,CAAC,OAAOE,KAAK,EAAE;IACZC,OAAO,CAACD,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;IACzD,MAAMA,KAAK;EACf;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMD,eAAe,GAAGA,CAACG,OAAO,EAAEC,IAAI,KAAK;EACvC,IAAI,CAACC,KAAK,CAACC,OAAO,CAACH,OAAO,CAAC,EAAE,OAAO,EAAE;EAEtC,OAAOA,OAAO,CAACI,GAAG,CAACC,MAAM;IAAA,IAAAC,aAAA,EAAAC,eAAA,EAAAC,gBAAA,EAAAC,gBAAA;IAAA,OAAK;MAC1BC,EAAE,EAAEL,MAAM,CAACK,EAAE;MACbC,OAAO,EAAEN,MAAM,CAACM,OAAO;MACvBC,QAAQ,EAAEP,MAAM,CAACO,QAAQ;MACzBC,KAAK,EAAE,EAAAP,aAAA,GAAAD,MAAM,CAACQ,KAAK,cAAAP,aAAA,uBAAZA,aAAA,CAAcQ,OAAO,KAAI,aAAa;MAC7CC,OAAO,EAAEV,MAAM,CAACW,GAAG,IAAI,qBAAqB;MAC5CC,OAAO,EAAE,GAAG,EAAAV,eAAA,GAAAF,MAAM,CAACY,OAAO,cAAAV,eAAA,uBAAdA,eAAA,CAAgBW,OAAO,KAAI,EAAE,KAAK,EAAAV,gBAAA,GAAAH,MAAM,CAACY,OAAO,cAAAT,gBAAA,uBAAdA,gBAAA,CAAgBW,GAAG,KAAI,EAAE,KAAK,EAAAV,gBAAA,GAAAJ,MAAM,CAACY,OAAO,cAAAR,gBAAA,uBAAdA,gBAAA,CAAgBW,IAAI,KAAI,EAAE,EAAE;MACxGC,GAAG,EAAEpB,IAAI,CAAE;IACf,CAAC;EAAA,CAAC,CAAC;AACP,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}