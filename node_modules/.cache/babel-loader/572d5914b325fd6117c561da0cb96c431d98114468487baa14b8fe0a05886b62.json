{"ast":null,"code":"const API_BASE_URL = 'http://localhost:8080/api'; // Base URL of your backend\n\n/**\n * Retrieves a token using basic authentication.\n * @returns {Promise<string>} - The retrieved token.\n */\nconst getToken = async () => {\n  try {\n    const credentials = btoa(\"MAR200575:geheim1\"); // Encode credentials\n    const response = await fetch(\"http://localhost:8080/token\", {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Basic ${credentials}`\n      }\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch token: ${response.statusText}`);\n    }\n    const token = await response.text(); // Assuming the token is a plain string\n    if (!token) {\n      throw new Error('Token is empty or invalid');\n    }\n    console.log(\"Token fetched successfully:\", token);\n    return token;\n  } catch (error) {\n    console.error('Error fetching token:', error);\n    throw error;\n  }\n};\n\n/**\n * Fetches data from an API endpoint using a Bearer token.\n * @param {string} endpoint - The endpoint to fetch data from.\n * @param {string} token - The Bearer token.\n * @returns {Promise<any>} - The response data.\n */\nconst fetchDataWithToken = async (endpoint, token) => {\n  try {\n    const response = await fetch(`${API_BASE_URL}${endpoint}`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}` // Use Bearer token\n      }\n    });\n    const text = await response.text();\n    console.log(`Raw response from ${endpoint}:`, text);\n    if (!response.ok) {\n      throw new Error(`Error fetching data from ${endpoint}: ${response.status} ${response.statusText}`);\n    }\n\n    // Parse JSON response with validation\n    try {\n      const data = JSON.parse(text);\n\n      // Detect excessive nesting or recursion\n      if (JSON.stringify(data).length > 100000) {\n        // Adjust size threshold as needed\n        throw new Error(`Response too large or possibly cyclic at ${endpoint}`);\n      }\n      console.log(`Parsed data from ${endpoint}:`, data);\n      return data;\n    } catch (parseError) {\n      console.error(`Error parsing JSON from ${endpoint}:`, parseError.message);\n      throw new Error(`Invalid JSON returned from ${endpoint}`);\n    }\n  } catch (error) {\n    console.error(`API Error (${endpoint}):`, error.message);\n    throw error;\n  }\n};\n\n/**\n * Fetches data from the API with automatic token handling.\n * @param {string} endpoint - The endpoint to fetch data from.\n * @returns {Promise<any>} - The fetched data.\n */\nexport const fetchData = async endpoint => {\n  try {\n    const token = await getToken();\n    const data = await fetchDataWithToken(endpoint, token);\n    if (!data) {\n      throw new Error(`No data returned from ${endpoint}`);\n    }\n    return data;\n  } catch (error) {\n    console.error('API Error:', error.message);\n    throw error;\n  }\n};\n\n/**\n * Utility function to perform POST, PUT, and DELETE requests.\n * @param {string} endpoint - API endpoint.\n * @param {string} method - HTTP method (POST, PUT, DELETE).\n * @param {Object} body - Request payload.\n * @param {Object} [options={}] - Additional fetch options.\n * @returns {Promise<any>} - Response data.\n */\nconst performWriteRequest = async (endpoint, method, body, options = {}) => {\n  try {\n    const token = await getToken();\n    const response = await fetch(`${API_BASE_URL}${endpoint}`, {\n      method,\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`\n      },\n      body: JSON.stringify(body),\n      ...options\n    });\n    if (!response.ok) {\n      throw new Error(`Error during ${method} request: ${response.statusText}`);\n    }\n    const data = await response.json();\n    console.log(`${method} response from ${endpoint}:`, data);\n    return data;\n  } catch (error) {\n    console.error(`API Error (${method} ${endpoint}):`, error.message);\n    throw error;\n  }\n};\nexport const postData = (endpoint, body, options = {}) => performWriteRequest(endpoint, 'POST', body, options);\nexport const updateData = (endpoint, body, options = {}) => performWriteRequest(endpoint, 'PUT', body, options);\nexport const deleteData = (endpoint, options = {}) => performWriteRequest(endpoint, 'DELETE', null, options);","map":{"version":3,"names":["API_BASE_URL","getToken","credentials","btoa","response","fetch","method","headers","ok","Error","statusText","token","text","console","log","error","fetchDataWithToken","endpoint","status","data","JSON","parse","stringify","length","parseError","message","fetchData","performWriteRequest","body","options","json","postData","updateData","deleteData"],"sources":["/Users/amelieploil/Desktop/Diploma/kinskyfe/src/Application/personService.js"],"sourcesContent":["const API_BASE_URL = 'http://localhost:8080/api'; // Base URL of your backend\n\n/**\n * Retrieves a token using basic authentication.\n * @returns {Promise<string>} - The retrieved token.\n */\nconst getToken = async () => {\n    try {\n        const credentials = btoa(\"MAR200575:geheim1\"); // Encode credentials\n        const response = await fetch(\"http://localhost:8080/token\", {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Basic ${credentials}`,\n            },\n        });\n\n        if (!response.ok) {\n            throw new Error(`Failed to fetch token: ${response.statusText}`);\n        }\n\n        const token = await response.text(); // Assuming the token is a plain string\n        if (!token) {\n            throw new Error('Token is empty or invalid');\n        }\n\n        console.log(\"Token fetched successfully:\", token);\n        return token;\n    } catch (error) {\n        console.error('Error fetching token:', error);\n        throw error;\n    }\n};\n\n/**\n * Fetches data from an API endpoint using a Bearer token.\n * @param {string} endpoint - The endpoint to fetch data from.\n * @param {string} token - The Bearer token.\n * @returns {Promise<any>} - The response data.\n */\nconst fetchDataWithToken = async (endpoint, token) => {\n    try {\n        const response = await fetch(`${API_BASE_URL}${endpoint}`, {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${token}`, // Use Bearer token\n            },\n        });\n\n        const text = await response.text();\n        console.log(`Raw response from ${endpoint}:`, text);\n\n        if (!response.ok) {\n            throw new Error(`Error fetching data from ${endpoint}: ${response.status} ${response.statusText}`);\n        }\n\n        // Parse JSON response with validation\n        try {\n            const data = JSON.parse(text);\n\n            // Detect excessive nesting or recursion\n            if (JSON.stringify(data).length > 100000) { // Adjust size threshold as needed\n                throw new Error(`Response too large or possibly cyclic at ${endpoint}`);\n            }\n\n            console.log(`Parsed data from ${endpoint}:`, data);\n            return data;\n        } catch (parseError) {\n            console.error(`Error parsing JSON from ${endpoint}:`, parseError.message);\n            throw new Error(`Invalid JSON returned from ${endpoint}`);\n        }\n    } catch (error) {\n        console.error(`API Error (${endpoint}):`, error.message);\n        throw error;\n    }\n};\n\n/**\n * Fetches data from the API with automatic token handling.\n * @param {string} endpoint - The endpoint to fetch data from.\n * @returns {Promise<any>} - The fetched data.\n */\nexport const fetchData = async (endpoint) => {\n    try {\n        const token = await getToken();\n        const data = await fetchDataWithToken(endpoint, token);\n\n        if (!data) {\n            throw new Error(`No data returned from ${endpoint}`);\n        }\n\n        return data;\n    } catch (error) {\n        console.error('API Error:', error.message);\n        throw error;\n    }\n};\n\n/**\n * Utility function to perform POST, PUT, and DELETE requests.\n * @param {string} endpoint - API endpoint.\n * @param {string} method - HTTP method (POST, PUT, DELETE).\n * @param {Object} body - Request payload.\n * @param {Object} [options={}] - Additional fetch options.\n * @returns {Promise<any>} - Response data.\n */\nconst performWriteRequest = async (endpoint, method, body, options = {}) => {\n    try {\n        const token = await getToken();\n        const response = await fetch(`${API_BASE_URL}${endpoint}`, {\n            method,\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${token}`,\n            },\n            body: JSON.stringify(body),\n            ...options,\n        });\n\n        if (!response.ok) {\n            throw new Error(`Error during ${method} request: ${response.statusText}`);\n        }\n\n        const data = await response.json();\n        console.log(`${method} response from ${endpoint}:`, data);\n        return data;\n    } catch (error) {\n        console.error(`API Error (${method} ${endpoint}):`, error.message);\n        throw error;\n    }\n};\n\nexport const postData = (endpoint, body, options = {}) => performWriteRequest(endpoint, 'POST', body, options);\nexport const updateData = (endpoint, body, options = {}) => performWriteRequest(endpoint, 'PUT', body, options);\nexport const deleteData = (endpoint, options = {}) => performWriteRequest(endpoint, 'DELETE', null, options);"],"mappings":"AAAA,MAAMA,YAAY,GAAG,2BAA2B,CAAC,CAAC;;AAElD;AACA;AACA;AACA;AACA,MAAMC,QAAQ,GAAG,MAAAA,CAAA,KAAY;EACzB,IAAI;IACA,MAAMC,WAAW,GAAGC,IAAI,CAAC,mBAAmB,CAAC,CAAC,CAAC;IAC/C,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAC,6BAA6B,EAAE;MACxDC,MAAM,EAAE,MAAM;MACdC,OAAO,EAAE;QACL,cAAc,EAAE,kBAAkB;QAClC,eAAe,EAAE,SAASL,WAAW;MACzC;IACJ,CAAC,CAAC;IAEF,IAAI,CAACE,QAAQ,CAACI,EAAE,EAAE;MACd,MAAM,IAAIC,KAAK,CAAC,0BAA0BL,QAAQ,CAACM,UAAU,EAAE,CAAC;IACpE;IAEA,MAAMC,KAAK,GAAG,MAAMP,QAAQ,CAACQ,IAAI,CAAC,CAAC,CAAC,CAAC;IACrC,IAAI,CAACD,KAAK,EAAE;MACR,MAAM,IAAIF,KAAK,CAAC,2BAA2B,CAAC;IAChD;IAEAI,OAAO,CAACC,GAAG,CAAC,6BAA6B,EAAEH,KAAK,CAAC;IACjD,OAAOA,KAAK;EAChB,CAAC,CAAC,OAAOI,KAAK,EAAE;IACZF,OAAO,CAACE,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;IAC7C,MAAMA,KAAK;EACf;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,kBAAkB,GAAG,MAAAA,CAAOC,QAAQ,EAAEN,KAAK,KAAK;EAClD,IAAI;IACA,MAAMP,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAGL,YAAY,GAAGiB,QAAQ,EAAE,EAAE;MACvDX,MAAM,EAAE,KAAK;MACbC,OAAO,EAAE;QACL,cAAc,EAAE,kBAAkB;QAClC,eAAe,EAAE,UAAUI,KAAK,EAAE,CAAE;MACxC;IACJ,CAAC,CAAC;IAEF,MAAMC,IAAI,GAAG,MAAMR,QAAQ,CAACQ,IAAI,CAAC,CAAC;IAClCC,OAAO,CAACC,GAAG,CAAC,qBAAqBG,QAAQ,GAAG,EAAEL,IAAI,CAAC;IAEnD,IAAI,CAACR,QAAQ,CAACI,EAAE,EAAE;MACd,MAAM,IAAIC,KAAK,CAAC,4BAA4BQ,QAAQ,KAAKb,QAAQ,CAACc,MAAM,IAAId,QAAQ,CAACM,UAAU,EAAE,CAAC;IACtG;;IAEA;IACA,IAAI;MACA,MAAMS,IAAI,GAAGC,IAAI,CAACC,KAAK,CAACT,IAAI,CAAC;;MAE7B;MACA,IAAIQ,IAAI,CAACE,SAAS,CAACH,IAAI,CAAC,CAACI,MAAM,GAAG,MAAM,EAAE;QAAE;QACxC,MAAM,IAAId,KAAK,CAAC,4CAA4CQ,QAAQ,EAAE,CAAC;MAC3E;MAEAJ,OAAO,CAACC,GAAG,CAAC,oBAAoBG,QAAQ,GAAG,EAAEE,IAAI,CAAC;MAClD,OAAOA,IAAI;IACf,CAAC,CAAC,OAAOK,UAAU,EAAE;MACjBX,OAAO,CAACE,KAAK,CAAC,2BAA2BE,QAAQ,GAAG,EAAEO,UAAU,CAACC,OAAO,CAAC;MACzE,MAAM,IAAIhB,KAAK,CAAC,8BAA8BQ,QAAQ,EAAE,CAAC;IAC7D;EACJ,CAAC,CAAC,OAAOF,KAAK,EAAE;IACZF,OAAO,CAACE,KAAK,CAAC,cAAcE,QAAQ,IAAI,EAAEF,KAAK,CAACU,OAAO,CAAC;IACxD,MAAMV,KAAK;EACf;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMW,SAAS,GAAG,MAAOT,QAAQ,IAAK;EACzC,IAAI;IACA,MAAMN,KAAK,GAAG,MAAMV,QAAQ,CAAC,CAAC;IAC9B,MAAMkB,IAAI,GAAG,MAAMH,kBAAkB,CAACC,QAAQ,EAAEN,KAAK,CAAC;IAEtD,IAAI,CAACQ,IAAI,EAAE;MACP,MAAM,IAAIV,KAAK,CAAC,yBAAyBQ,QAAQ,EAAE,CAAC;IACxD;IAEA,OAAOE,IAAI;EACf,CAAC,CAAC,OAAOJ,KAAK,EAAE;IACZF,OAAO,CAACE,KAAK,CAAC,YAAY,EAAEA,KAAK,CAACU,OAAO,CAAC;IAC1C,MAAMV,KAAK;EACf;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMY,mBAAmB,GAAG,MAAAA,CAAOV,QAAQ,EAAEX,MAAM,EAAEsB,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,KAAK;EACxE,IAAI;IACA,MAAMlB,KAAK,GAAG,MAAMV,QAAQ,CAAC,CAAC;IAC9B,MAAMG,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAGL,YAAY,GAAGiB,QAAQ,EAAE,EAAE;MACvDX,MAAM;MACNC,OAAO,EAAE;QACL,cAAc,EAAE,kBAAkB;QAClC,eAAe,EAAE,UAAUI,KAAK;MACpC,CAAC;MACDiB,IAAI,EAAER,IAAI,CAACE,SAAS,CAACM,IAAI,CAAC;MAC1B,GAAGC;IACP,CAAC,CAAC;IAEF,IAAI,CAACzB,QAAQ,CAACI,EAAE,EAAE;MACd,MAAM,IAAIC,KAAK,CAAC,gBAAgBH,MAAM,aAAaF,QAAQ,CAACM,UAAU,EAAE,CAAC;IAC7E;IAEA,MAAMS,IAAI,GAAG,MAAMf,QAAQ,CAAC0B,IAAI,CAAC,CAAC;IAClCjB,OAAO,CAACC,GAAG,CAAC,GAAGR,MAAM,kBAAkBW,QAAQ,GAAG,EAAEE,IAAI,CAAC;IACzD,OAAOA,IAAI;EACf,CAAC,CAAC,OAAOJ,KAAK,EAAE;IACZF,OAAO,CAACE,KAAK,CAAC,cAAcT,MAAM,IAAIW,QAAQ,IAAI,EAAEF,KAAK,CAACU,OAAO,CAAC;IAClE,MAAMV,KAAK;EACf;AACJ,CAAC;AAED,OAAO,MAAMgB,QAAQ,GAAGA,CAACd,QAAQ,EAAEW,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,KAAKF,mBAAmB,CAACV,QAAQ,EAAE,MAAM,EAAEW,IAAI,EAAEC,OAAO,CAAC;AAC9G,OAAO,MAAMG,UAAU,GAAGA,CAACf,QAAQ,EAAEW,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,KAAKF,mBAAmB,CAACV,QAAQ,EAAE,KAAK,EAAEW,IAAI,EAAEC,OAAO,CAAC;AAC/G,OAAO,MAAMI,UAAU,GAAGA,CAAChB,QAAQ,EAAEY,OAAO,GAAG,CAAC,CAAC,KAAKF,mBAAmB,CAACV,QAAQ,EAAE,QAAQ,EAAE,IAAI,EAAEY,OAAO,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}