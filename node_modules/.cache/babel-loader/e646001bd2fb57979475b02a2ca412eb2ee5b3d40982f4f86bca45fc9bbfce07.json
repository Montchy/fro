{"ast":null,"code":"import getAlphanumFromUnicodeRange from './getAlphanumFromUnicodeRange';\nimport makeAlphanumMaxlenComputer from './makeAlphanumMaxlenComputer';\nimport makeCSEngine from './makeCSEngine';\nimport makeCSRenderer from './makeCSRenderer';\nimport codepointLength from './utils/codepointLength';\nconst mod = (value, divisor) => (value % divisor + divisor) % divisor;\nfunction makeCSRendererFromFormatter(formatter) {\n  return makeCSRenderer(makeCSEngine(formatter));\n}\nfunction getMaxLenInSymbols(lens) {\n  let from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let to = arguments.length > 2 ? arguments[2] : undefined;\n  to = typeof to === 'number' ? to : lens.length;\n  return lens.slice(from, to + 1).reduce((p, c) => Math.max(p, c), 0);\n}\nfunction numeric(renderer, length) {\n  return renderer.withMaxLengthComputer(makeAlphanumMaxlenComputer(length, false)).withNegative('-');\n}\nfunction alphabetic(renderer, length) {\n  return renderer.withMaxLengthComputer(makeAlphanumMaxlenComputer(length, true)).withRange(1, Infinity);\n}\n/**\n * A static object to build counter style renderers.\n * See {@link CounterStyleStatic}.\n *\n * @public\n */\nconst CounterStyle = Object.freeze({\n  raw: formatter => {\n    return makeCSRendererFromFormatter(formatter);\n  },\n  cyclic: function () {\n    for (var _len = arguments.length, symbols = new Array(_len), _key = 0; _key < _len; _key++) {\n      symbols[_key] = arguments[_key];\n    }\n    const symbolLenghts = symbols.map(codepointLength);\n    const maxLen = getMaxLenInSymbols(symbolLenghts);\n    const renderer = symbols.length === 1 ? makeCSRendererFromFormatter(() => symbols[0]) : makeCSRendererFromFormatter(index => symbols[mod(index - 1, symbols.length)]);\n    return renderer.withMaxLengthComputer((min, max) => {\n      return maxLen === 1 || max - min + 1 >= symbols.length ? maxLen : getMaxLenInSymbols(symbolLenghts, min - 1, max - 1);\n    });\n  },\n  fixed: function () {\n    for (var _len2 = arguments.length, symbols = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      symbols[_key2] = arguments[_key2];\n    }\n    const symbolLenghts = symbols.map(codepointLength);\n    const maxLen = getMaxLenInSymbols(symbolLenghts);\n    return makeCSRendererFromFormatter(index => symbols[index - 1]).withRange(1, symbols.length).withMaxLengthComputer((min, max) => {\n      return maxLen === 1 ? maxLen : getMaxLenInSymbols(symbolLenghts, min - 1, max - 1);\n    });\n  },\n  symbolic: function () {\n    for (var _len3 = arguments.length, symbols = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      symbols[_key3] = arguments[_key3];\n    }\n    return makeCSRendererFromFormatter(index => symbols[mod(index - 1, symbols.length)].repeat(Math.ceil(index / symbols.length))).withRange(1, Infinity).withMaxLengthComputer((min, max, defaultCmp) => {\n      // Just iterate over the last n elements until max, with n the number\n      // of symbols.\n      return defaultCmp(max < symbols.length ? min : max - symbols.length, max);\n    });\n  },\n  alphabetic: function () {\n    for (var _len4 = arguments.length, symbols = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      symbols[_key4] = arguments[_key4];\n    }\n    return alphabetic(makeCSRendererFromFormatter(index => {\n      let result = '';\n      while (index > 0) {\n        index--;\n        result = symbols[mod(index, symbols.length)] + result;\n        index = Math.floor(index / symbols.length);\n      }\n      return result;\n    }), symbols.length);\n  },\n  numeric: function () {\n    for (var _len5 = arguments.length, symbols = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      symbols[_key5] = arguments[_key5];\n    }\n    return numeric(makeCSRendererFromFormatter(index => {\n      if (index === 0) {\n        return symbols[0];\n      } else {\n        let result = '';\n        while (index > 0) {\n          result = symbols[mod(index, symbols.length)] + result;\n          index = Math.floor(index / symbols.length);\n        }\n        return result;\n      }\n    }), symbols.length);\n  },\n  numericFromUnicodeRange: (originUnicode, base) => {\n    return numeric(makeCSRendererFromFormatter(index => getAlphanumFromUnicodeRange(index, originUnicode, base, false)), base);\n  },\n  alphabeticFromUnicodeRange: (originUnicode, alphabetLen) => {\n    return alphabetic(makeCSRendererFromFormatter(index => {\n      return getAlphanumFromUnicodeRange(index, originUnicode, alphabetLen, true);\n    }), alphabetLen);\n  },\n  additive: symbols => {\n    const values = Object.keys(symbols).map(value => parseInt(value, 10)).sort((a, b) => b - a);\n    return makeCSRendererFromFormatter(index => {\n      if (index === 0) {\n        return symbols[0];\n      }\n      let result = '';\n      for (const value of values) {\n        if (index >= value && value > 0) {\n          const repeat = Math.floor(index / value);\n          result += symbols[value].repeat(repeat);\n          index -= repeat * value;\n        }\n      }\n      return index === 0 ? result : undefined;\n    }).withRange(values.length ? values[values.length - 1] : 0, 0 in symbols && values.length === 1 ? 0 : values.length ? Infinity : -1);\n  }\n});\nexport default CounterStyle;","map":{"version":3,"names":["getAlphanumFromUnicodeRange","makeAlphanumMaxlenComputer","makeCSEngine","makeCSRenderer","codepointLength","mod","value","divisor","makeCSRendererFromFormatter","formatter","getMaxLenInSymbols","lens","from","arguments","length","undefined","to","slice","reduce","p","c","Math","max","numeric","renderer","withMaxLengthComputer","withNegative","alphabetic","withRange","Infinity","CounterStyle","Object","freeze","raw","cyclic","_len","symbols","Array","_key","symbolLenghts","map","maxLen","index","min","fixed","_len2","_key2","symbolic","_len3","_key3","repeat","ceil","defaultCmp","_len4","_key4","result","floor","_len5","_key5","numericFromUnicodeRange","originUnicode","base","alphabeticFromUnicodeRange","alphabetLen","additive","values","keys","parseInt","sort","a","b"],"sources":["/Users/amelieploil/Desktop/Diploma/kinskyfe/node_modules/@jsamr/counter-style/src/CounterStyle.ts"],"sourcesContent":["import getAlphanumFromUnicodeRange from './getAlphanumFromUnicodeRange';\nimport makeAlphanumMaxlenComputer from './makeAlphanumMaxlenComputer';\nimport makeCSEngine from './makeCSEngine';\nimport makeCSRenderer from './makeCSRenderer';\nimport type {\n  InitialCounterFormatter,\n  CounterStyleStatic,\n  CounterStyleRenderer\n} from './public-types';\nimport codepointLength from './utils/codepointLength';\n\nconst mod = (value: number, divisor: number) =>\n  ((value % divisor) + divisor) % divisor;\n\nfunction makeCSRendererFromFormatter(formatter: InitialCounterFormatter) {\n  return makeCSRenderer(makeCSEngine(formatter));\n}\n\nfunction getMaxLenInSymbols(lens: number[], from = 0, to?: number) {\n  to = typeof to === 'number' ? to : lens.length;\n  return lens.slice(from, to + 1).reduce((p, c) => Math.max(p, c), 0);\n}\n\nfunction numeric(renderer: CounterStyleRenderer, length: number) {\n  return renderer\n    .withMaxLengthComputer(makeAlphanumMaxlenComputer(length, false))\n    .withNegative('-');\n}\n\nfunction alphabetic(renderer: CounterStyleRenderer, length: number) {\n  return renderer\n    .withMaxLengthComputer(makeAlphanumMaxlenComputer(length, true))\n    .withRange(1, Infinity);\n}\n\n/**\n * A static object to build counter style renderers.\n * See {@link CounterStyleStatic}.\n *\n * @public\n */\nconst CounterStyle: Readonly<CounterStyleStatic> = Object.freeze({\n  raw: (formatter) => {\n    return makeCSRendererFromFormatter(formatter);\n  },\n  cyclic: (...symbols) => {\n    const symbolLenghts = symbols.map(codepointLength);\n    const maxLen = getMaxLenInSymbols(symbolLenghts);\n    const renderer =\n      symbols.length === 1\n        ? makeCSRendererFromFormatter(() => symbols[0])\n        : makeCSRendererFromFormatter(\n            (index) => symbols[mod(index - 1, symbols.length)]\n          );\n    return renderer.withMaxLengthComputer((min, max) => {\n      return maxLen === 1 || max - min + 1 >= symbols.length\n        ? maxLen\n        : getMaxLenInSymbols(symbolLenghts, min - 1, max - 1);\n    });\n  },\n  fixed: (...symbols) => {\n    const symbolLenghts = symbols.map(codepointLength);\n    const maxLen = getMaxLenInSymbols(symbolLenghts);\n    return makeCSRendererFromFormatter((index) => symbols[index - 1])\n      .withRange(1, symbols.length)\n      .withMaxLengthComputer((min, max) => {\n        return maxLen === 1\n          ? maxLen\n          : getMaxLenInSymbols(symbolLenghts, min - 1, max - 1);\n      });\n  },\n  symbolic: (...symbols) =>\n    makeCSRendererFromFormatter((index) =>\n      symbols[mod(index - 1, symbols.length)].repeat(\n        Math.ceil(index / symbols.length)\n      )\n    )\n      .withRange(1, Infinity)\n      .withMaxLengthComputer((min, max, defaultCmp) => {\n        // Just iterate over the last n elements until max, with n the number\n        // of symbols.\n        return defaultCmp(\n          max < symbols.length ? min : max - symbols.length,\n          max\n        );\n      }),\n  alphabetic: (...symbols) => {\n    return alphabetic(\n      makeCSRendererFromFormatter((index) => {\n        let result = '';\n        while (index > 0) {\n          index--;\n          result = symbols[mod(index, symbols.length)] + result;\n          index = Math.floor(index / symbols.length);\n        }\n        return result;\n      }),\n      symbols.length\n    );\n  },\n  numeric: (...symbols) => {\n    return numeric(\n      makeCSRendererFromFormatter((index) => {\n        if (index === 0) {\n          return symbols[0];\n        } else {\n          let result = '';\n          while (index > 0) {\n            result = symbols[mod(index, symbols.length)] + result;\n            index = Math.floor(index / symbols.length);\n          }\n          return result;\n        }\n      }),\n      symbols.length\n    );\n  },\n  numericFromUnicodeRange: (originUnicode: number, base: number) => {\n    return numeric(\n      makeCSRendererFromFormatter(\n        (index) =>\n          getAlphanumFromUnicodeRange(\n            index,\n            originUnicode,\n            base,\n            false\n          ) as string\n      ),\n      base\n    );\n  },\n  alphabeticFromUnicodeRange: (originUnicode: number, alphabetLen: number) => {\n    return alphabetic(\n      makeCSRendererFromFormatter((index) => {\n        return getAlphanumFromUnicodeRange(\n          index,\n          originUnicode,\n          alphabetLen,\n          true\n        );\n      }),\n      alphabetLen\n    );\n  },\n  additive: (symbols: { [value: number]: string }) => {\n    const values = Object.keys(symbols)\n      .map((value) => parseInt(value, 10))\n      .sort((a, b) => b - a);\n    return makeCSRendererFromFormatter((index) => {\n      if (index === 0) {\n        return symbols[0];\n      }\n      let result = '';\n      for (const value of values) {\n        if (index >= value && value > 0) {\n          const repeat = Math.floor(index / value);\n          result += symbols[value].repeat(repeat);\n          index -= repeat * value;\n        }\n      }\n      return index === 0 ? result : undefined;\n    }).withRange(\n      values.length ? values[values.length - 1] : 0,\n      0 in symbols && values.length === 1 ? 0 : values.length ? Infinity : -1\n    );\n  }\n});\n\nexport default CounterStyle;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}