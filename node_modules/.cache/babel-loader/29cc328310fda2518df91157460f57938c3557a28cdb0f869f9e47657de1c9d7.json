{"ast":null,"code":"import ApiService from\"../Application/ApiService\";/**\n * Führt eine Fetch-Funktion aus, protokolliert die Antwort und behandelt Fehler.\n * @param {string} type - Der Typ der Datenquelle (z. B. \"Vermittler\").\n * @param {Function} fetchFunction - Die Fetch-Funktion für die API.\n * @returns {Promise<Array>} - Die bereinigte API-Antwort oder ein leeres Array.\n */const fetchAndLog=async(type,fetchFunction)=>{try{const response=await fetchFunction();if(!response){console.warn(\"\".concat(type,\" API hat keine Daten zur\\xFCckgegeben.\"));return[];}//console.log(`Raw ${type} response:`, response);\nconst sanitizedResponse=sanitizeData(response);//console.log(`Sanitized ${type} data:`, sanitizedResponse);\nreturn sanitizedResponse;}catch(error){console.error(\"Fehler beim Abrufen von \".concat(type,\":\"),error);return[];}};/**\n * Entfernt zirkuläre Referenzen und verschachtelte Strukturen.\n * @param {Object} data - Die zu bereinigenden Daten.\n * @param {Set} seen - Set, um bereits besuchte Objekte zu verfolgen.\n * @returns {Object} - Bereinigte Daten.\n */const sanitizeData=function(data){let seen=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new WeakSet();if(data&&typeof data==='object'){if(seen.has(data)){return undefined;// Zirkuläre Referenzen entfernen\n}seen.add(data);const sanitized=Array.isArray(data)?[]:{};for(const key in data){if(key==='betreuer'||key==='einbringer'||key==='vermittler'){sanitized[key]=undefined;// Tiefe Referenzen entfernen\n}else{sanitized[key]=sanitizeData(data[key],seen);}}return sanitized;}return data;};/**\n * Ruft alle Personen aus verschiedenen Endpunkten ab und führt sie zu einer Liste zusammen.\n * @returns {Promise<Array>} - Eine zusammengeführte Liste von Personen.\n */export const fetchAllPersons=async()=>{try{const vermittler=await fetchAndLog(\"Vermittler\",ApiService.fetchVermittler);const einbringer=await fetchAndLog(\"Einbringer\",ApiService.fetchEinbringer);const betreuer=await fetchAndLog(\"Betreuer\",ApiService.fetchBetreuer);const allPersons=[...sanitizePersons(vermittler,\"Vermittler\"),...sanitizePersons(einbringer,\"Einbringer\"),...sanitizePersons(betreuer,\"Betreuer\")];//console.log(\"Zusammengeführte Personenliste:\", allPersons);\nreturn allPersons;}catch(error){//console.error(\"Fehler beim Abrufen der Personen:\", error);\nthrow error;}};/**\n * Bereinigt und formatiert die Liste der Personen aus einer bestimmten Quelle.\n * @param {Array} persons - Die ursprüngliche Personenliste.\n * @param {string} type - Der Typ der Quelle (z. B. \"Vermittler\", \"Einbringer\", \"Betreuer\").\n * @returns {Array} - Die bereinigte und formattierte Personenliste.\n */const sanitizePersons=(persons,type)=>{if(!Array.isArray(persons)){console.warn(\"Erwartete ein Array, aber erhalten:\",persons);return[];}return persons.map(person=>{var _person$email,_person$adresse,_person$adresse2,_person$adresse3;return{id:person.id,vorname:person.vorname||\"Unbekannt\",nachname:person.nachname||\"Unbekannt\",email:((_person$email=person.email)===null||_person$email===void 0?void 0:_person$email.address)||\"Keine Email\",telefon:person.tel||\"Keine Telefonnummer\",adresse:[((_person$adresse=person.adresse)===null||_person$adresse===void 0?void 0:_person$adresse.strasse)||\"\",((_person$adresse2=person.adresse)===null||_person$adresse2===void 0?void 0:_person$adresse2.ort)||\"\",((_person$adresse3=person.adresse)===null||_person$adresse3===void 0?void 0:_person$adresse3.land)||\"\"].filter(Boolean).join(\", \"),typ:type};});};","map":{"version":3,"names":["ApiService","fetchAndLog","type","fetchFunction","response","console","warn","concat","sanitizedResponse","sanitizeData","error","data","seen","arguments","length","undefined","WeakSet","has","add","sanitized","Array","isArray","key","fetchAllPersons","vermittler","fetchVermittler","einbringer","fetchEinbringer","betreuer","fetchBetreuer","allPersons","sanitizePersons","persons","map","person","_person$email","_person$adresse","_person$adresse2","_person$adresse3","id","vorname","nachname","email","address","telefon","tel","adresse","strasse","ort","land","filter","Boolean","join","typ"],"sources":["/Users/amelieploil/Desktop/Diploma/kinskyfe/src/Application/personService.js"],"sourcesContent":["import ApiService from \"../Application/ApiService\";\n\n/**\n * Führt eine Fetch-Funktion aus, protokolliert die Antwort und behandelt Fehler.\n * @param {string} type - Der Typ der Datenquelle (z. B. \"Vermittler\").\n * @param {Function} fetchFunction - Die Fetch-Funktion für die API.\n * @returns {Promise<Array>} - Die bereinigte API-Antwort oder ein leeres Array.\n */\nconst fetchAndLog = async (type, fetchFunction) => {\n    try {\n        const response = await fetchFunction();\n\n        if (!response) {\n            console.warn(`${type} API hat keine Daten zurückgegeben.`);\n            return [];\n        }\n\n        //console.log(`Raw ${type} response:`, response);\n\n        const sanitizedResponse = sanitizeData(response);\n        //console.log(`Sanitized ${type} data:`, sanitizedResponse);\n\n        return sanitizedResponse;\n    } catch (error) {\n        console.error(`Fehler beim Abrufen von ${type}:`, error);\n        return [];\n    }\n};\n\n/**\n * Entfernt zirkuläre Referenzen und verschachtelte Strukturen.\n * @param {Object} data - Die zu bereinigenden Daten.\n * @param {Set} seen - Set, um bereits besuchte Objekte zu verfolgen.\n * @returns {Object} - Bereinigte Daten.\n */\nconst sanitizeData = (data, seen = new WeakSet()) => {\n    if (data && typeof data === 'object') {\n        if (seen.has(data)) {\n            return undefined; // Zirkuläre Referenzen entfernen\n        }\n        seen.add(data);\n\n        const sanitized = Array.isArray(data) ? [] : {};\n        for (const key in data) {\n            if (key === 'betreuer' || key === 'einbringer' || key === 'vermittler') {\n                sanitized[key] = undefined; // Tiefe Referenzen entfernen\n            } else {\n                sanitized[key] = sanitizeData(data[key], seen);\n            }\n        }\n        return sanitized;\n    }\n    return data;\n};\n\n/**\n * Ruft alle Personen aus verschiedenen Endpunkten ab und führt sie zu einer Liste zusammen.\n * @returns {Promise<Array>} - Eine zusammengeführte Liste von Personen.\n */\nexport const fetchAllPersons = async () => {\n    try {\n        const vermittler = await fetchAndLog(\"Vermittler\", ApiService.fetchVermittler);\n        const einbringer = await fetchAndLog(\"Einbringer\", ApiService.fetchEinbringer);\n        const betreuer = await fetchAndLog(\"Betreuer\", ApiService.fetchBetreuer);\n\n        const allPersons = [\n            ...sanitizePersons(vermittler, \"Vermittler\"),\n            ...sanitizePersons(einbringer, \"Einbringer\"),\n            ...sanitizePersons(betreuer, \"Betreuer\"),\n        ];\n\n        //console.log(\"Zusammengeführte Personenliste:\", allPersons);\n        return allPersons;\n    } catch (error) {\n        //console.error(\"Fehler beim Abrufen der Personen:\", error);\n        throw error;\n    }\n};\n\n/**\n * Bereinigt und formatiert die Liste der Personen aus einer bestimmten Quelle.\n * @param {Array} persons - Die ursprüngliche Personenliste.\n * @param {string} type - Der Typ der Quelle (z. B. \"Vermittler\", \"Einbringer\", \"Betreuer\").\n * @returns {Array} - Die bereinigte und formattierte Personenliste.\n */\nconst sanitizePersons = (persons, type) => {\n    if (!Array.isArray(persons)) {\n        console.warn(`Erwartete ein Array, aber erhalten:`, persons);\n        return [];\n    }\n\n    return persons.map(person => ({\n        id: person.id,\n        vorname: person.vorname || \"Unbekannt\",\n        nachname: person.nachname || \"Unbekannt\",\n        email: person.email?.address || \"Keine Email\",\n        telefon: person.tel || \"Keine Telefonnummer\",\n        adresse: [\n            person.adresse?.strasse || \"\",\n            person.adresse?.ort || \"\",\n            person.adresse?.land || \"\",\n        ].filter(Boolean).join(\", \"),\n        typ: type,\n    }));\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}